<!doctype html>
<html>
   <body>
    <canvas id="c" style="border:1px solid grey;width:100%;"></canvas>
    <div id="uiContainer">
        <div id="ui">
          <div id="seek">
            <span>seek</span><input value=0 step=1 min=0 max=249 id="seekrange" type="range" />
          </div>
        </div>
    </div>
    <script src="./rxjs.min.js"></script>
    <script id="vertex-shader-2d" type="notjs">
        attribute vec2 a_position;
 
        uniform vec2 u_resolution;
        uniform vec2 u_translation;
        uniform vec2 u_rotation;


        void main() {
            // Rotate the position
            vec2 rotatedPosition = vec2(
               a_position.x * u_rotation.y + a_position.y * u_rotation.x,
               a_position.y * u_rotation.y - a_position.x * u_rotation.x);
          
            // Add in the translation.
            vec2 position = rotatedPosition + u_translation;
          
            // convert the position from pixels to 0.0 to 1.0
            vec2 zeroToOne = position / u_resolution;
          
            // convert from 0->1 to 0->2
            vec2 zeroToTwo = zeroToOne * 2.0;
          
            // convert from 0->2 to -1->+1 (clipspace)
            vec2 clipSpace = zeroToTwo - 1.0;
          
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
          }
    </script>
    <script id="fragment-shader-2d" type="notjs">
    
    // fragment shaders don't have a default precision so we need
    // to pick one. mediump is a good default
    precision mediump float;

    //colo4 uniform input
    uniform vec4 u_color;
    
    void main() {
        // gl_FragColor is a special variable a fragment shader
        // is responsible for setting
        //vec4(1, 0, 0.5, 1); // return reddish-purple
        gl_FragColor = u_color; 
    }
    
    </script>
		
    <script type="module">
        import {createProgram, createShader} from './web-gl.mjs';
        import { objWithinEvent2 } from './events.mjs';
         var canvas = document.querySelector("#c");
         var gl = canvas.getContext("webgl");
         if (!gl) {
             console.log('no webgl support');
         }

        let mainObj = setup(gl),
        program = mainObj.program,
        positionAttributeLocation = mainObj.positionAttributeLocation;


  // Create a buffer to put positions in
  var positionBuffer = gl.createBuffer();

  // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

  var translation = [0, 0];
  var rotation = [0, 1];



  var width = 70;
  var height = 30;
  var color = [Math.random(), Math.random(), Math.random(), 1];
  let seekrange = document.getElementById('seekrange');

  // Setup a rectangle
  setRectangle(gl, translation[0], translation[1], width, height);

  drawScene(gl,mainObj);

  main(gl,mainObj);

   let angle = 360;
   let eventLocation = 0;

    var yup =  new rxjs.Observable(subscriber => {
      let counter = 0,
        intervalThing = setInterval(()=>{
            subscriber.next(objWithinEvent2[eventLocation]);
            if(!objWithinEvent2[eventLocation]){
                console.log('done');
                clearInterval(intervalThing);
                subscriber.complete();
            }
        },20);
    });

    let thing = yup.subscribe((thing)=>{
        translation = thing.translation;
        rotation = thing.rotation;
        eventLocation += 1;
        seekrange.value = eventLocation;
        drawScene(gl,mainObj);
    });

/*     setTimeout(()=>{
        thing.unsubscribe();
    },1000); */


/*   var yup = rxjs.of('test').subscribe((thing)=>{
    console.log(thing);
  });
 */
  
function main(gl,mainObj){
    seekrange.onchange = test(gl,mainObj);
    seekrange.oninput = function(event){
        thing.unsubscribe();
        let location = parseInt(event.target.value);
        let stamp = objWithinEvent2[location];
        translation = stamp.translation;
        rotation = stamp.rotation;
        drawScene(gl,mainObj);
    }
}

function test(gl,mainObj) {
    return function(event) {
        thing.unsubscribe();
        eventLocation = parseInt(event.target.value);
        thing = yup.subscribe((res)=>{
            if(thing){
                translation = res.translation;
                rotation = res.rotation;
                eventLocation += 1;
                seekrange.value = eventLocation;
                drawScene(gl,mainObj);
            }
        });
    }
}

function printSineAndCosineForAnAngle(angleInDegrees) {
  var angleInRadians = angleInDegrees * Math.PI / 180;
  return [Math.sin(angleInRadians), Math.cos(angleInRadians)];
}

function updatePosition(index,gl,mainObj) {
    return function(event) {
      console.log(event.target.value);
      translation[index] = parseInt(event.target.value);
      drawScene(gl,mainObj);
    };
}


  // Draw a the scene.
  function drawScene(gl, {positionAttributeLocation, resolutionUniformLocation, colorUniformLocation, translationLocation, rotationLocation}) { 

    // Tell WebGL how to convert from clip space to pixels
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
 
    // Clear the canvas.
    gl.clear(gl.COLOR_BUFFER_BIT);
 
    // Tell it to use our program (pair of shaders)
    gl.useProgram(program);
 
    // Turn on the attribute
    gl.enableVertexAttribArray(positionAttributeLocation);
 
    // Bind the position buffer.
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
 
    // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
    var size = 2;          // 2 components per iteration
    var type = gl.FLOAT;   // the data is 32bit floats
    var normalize = false; // don't normalize the data
    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
    var offset = 0;        // start at the beginning of the buffer
    gl.vertexAttribPointer(
        positionAttributeLocation, size, type, normalize, stride, offset)
 
    // set the resolution
    gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
 
    // set the color
    gl.uniform4fv(colorUniformLocation, color);

    // Set the translation.
    gl.uniform2fv(translationLocation, translation);

    // Set the rotation.
    gl.uniform2fv(rotationLocation, rotation);
 
    // Draw the rectangle.
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 6;
    gl.drawArrays(primitiveType, offset, count);
  }
 
// Fills the buffer with the values that define a rectangle.
function setRectangle(gl, x, y, width, height) {
  let x1 = x,
    x2 = x + width,
    y1 = y,
    y2 = y + height;
 
  // NOTE: gl.bufferData(gl.ARRAY_BUFFER, ...) will affect
  // whatever buffer is bound to the `ARRAY_BUFFER` bind point
  // but so far we only have one buffer. If we had more than one
  // buffer we'd want to bind that buffer to `ARRAY_BUFFER` first.
 
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
     x1, y1,
     x2, y1,
     x1, y2,
     x1, y2,
     x2, y1,
     x2, y2]), gl.STATIC_DRAW);
}

function setup(gl) {

             // Grab C++ code..?
    var vertexShaderSource = document.querySelector("#vertex-shader-2d").text,
        fragmentShaderSource = document.querySelector("#fragment-shader-2d").text,
        vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource),
        fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource),
        program = createProgram(gl, vertexShader, fragmentShader),
        positionAttributeLocation = gl.getAttribLocation(program, "a_position"),
        positionBuffer = gl.createBuffer(),
        resolutionUniformLocation = gl.getUniformLocation(program, "u_resolution"),
        colorUniformLocation = gl.getUniformLocation(program, "u_color"),
        translationLocation = gl.getUniformLocation(program, "u_translation"),
        rotationLocation = gl.getUniformLocation(program, "u_rotation");

        /* webglUtils. */
        resizeCanvasToDisplaySize(gl.canvas);

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        // Clear the canvas
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Tell it to use our program (pair of shaders)
        gl.useProgram(program);

        // set the resolution
        gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);

        gl.enableVertexAttribArray(positionAttributeLocation);

        // Bind the position buffer.
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
        var size = 2;          // 2 components per iteration
        var type = gl.FLOAT;   // the data is 32bit floats
        var normalize = false; // don't normalize the data
        var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
        var offset = 0;        // start at the beginning of the buffer
        gl.vertexAttribPointer(
            positionAttributeLocation, size, type, normalize, stride, offset);

        return {program, positionAttributeLocation, resolutionUniformLocation, colorUniformLocation, translationLocation, rotationLocation};

}


function resizeCanvasToDisplaySize(canvas) {
  // Lookup the size the browser is displaying the canvas in CSS pixels.
  const displayWidth  = canvas.clientWidth;
  const displayHeight = canvas.clientHeight;
 
  // Check if the canvas is not the same size.
  const needResize = canvas.width  !== displayWidth ||
                     canvas.height !== displayHeight;
 
  if (needResize) {
    // Make the canvas the same size
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
  }
 
  return needResize;
}

      </script>
   </body>
</html>